name: AutoUI Discussion Bot (Vue + AntV)

on:
  discussion:
    types: [created, labeled, edited]
  discussion_comment:
    types: [created, edited]

permissions:
  contents: write
  discussions: write

jobs:
  autoui:
    runs-on: ubuntu-latest

    # Only run when discussion has label "AutoUI"
    if: ${{ contains(toJson(github.event.discussion.labels.*.name), 'AutoUI') }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Load questions config
        id: cfg
        run: |
          set -euo pipefail
          test -f .github/templates/autoui/questions.json
          echo "ok=true" >> "$GITHUB_OUTPUT"

      - name: Parse discussion for answers + decide next question
        id: decide
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");

            const cfg = JSON.parse(fs.readFileSync(".github/templates/autoui/questions.json", "utf8"));
            const discussion = context.payload.discussion;

            // Fetch recent comments (GraphQL)
            const q = `
              query($id: ID!, $n: Int!) {
                node(id: $id) {
                  ... on Discussion {
                    id
                    title
                    body
                    comments(first: $n) {
                      nodes { body author { login } }
                    }
                  }
                }
              }`;
            const data = await github.graphql(q, { id: discussion.node_id, n: 50 });
            const node = data.node;

            const textBlob = [
              node.body || "",
              ...(node.comments.nodes || []).map(c => c.body || "")
            ].join("\n\n");

            // Parse "key: value" answers
            const answers = {};
            for (const item of cfg.questions) {
              const re = new RegExp(`(?:^|\\n)\\s*${item.key}\\s*:\\s*([^\\n]+)`, "i");
              const m = textBlob.match(re);
              if (m && m[1]) answers[item.key] = m[1].trim();
            }

            // Decide next unanswered
            const next = cfg.questions.find(q => !answers[q.key]);

            // Status block for the comment
            const lines = cfg.questions.map(q => {
              const v = answers[q.key] ? `✅ ${answers[q.key]}` : "❌ (missing)";
              return `- \`${q.key}\`: ${v}`;
            });

            core.setOutput("answers_json", JSON.stringify(answers));
            core.setOutput("status_block", lines.join("\n"));
            core.setOutput("next_key", next ? next.key : "");
            core.setOutput("next_question", next ? next.ask : "");
            core.setOutput("complete", next ? "false" : "true");

      - name: Render reply comment from template
        id: render_reply
        shell: bash
        run: |
          set -euo pipefail

          STATUS_BLOCK="${{ steps.decide.outputs.status_block }}"
          NEXT_QUESTION="${{ steps.decide.outputs.next_question }}"

          # log variables before rendering (as requested)
          echo "STATUS_BLOCK:"
          echo "$STATUS_BLOCK"
          echo "NEXT_QUESTION:"
          echo "$NEXT_QUESTION"

          # export for envsubst
          export STATUS_BLOCK NEXT_QUESTION
          envsubst < .github/templates/autoui/reply.md > /tmp/autoui-reply.md

          echo "Rendered reply:"
          cat /tmp/autoui-reply.md

      - name: Comment next question (if not complete)
        if: ${{ steps.decide.outputs.complete == 'false' }}
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");
            const body = fs.readFileSync("/tmp/autoui-reply.md", "utf8");
            const discussionId = context.payload.discussion.node_id;

            await github.graphql(
              `mutation($discussionId: ID!, $body: String!) {
                addDiscussionComment(input: { discussionId: $discussionId, body: $body }) {
                  comment { id }
                }
              }`,
              { discussionId, body }
            );

      - name: Setup Node (only when generating code)
        if: ${{ steps.decide.outputs.complete == 'true' }}
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Generate Vue + AntV files from templates (when complete)
        if: ${{ steps.decide.outputs.complete == 'true' }}
        shell: bash
        run: |
          set -euo pipefail

          answers='${{ steps.decide.outputs.answers_json }}'
          echo "Answers JSON: $answers"

          # Extract with node (available after setup-node)
          PRODUCT_NAME="$(node -p "JSON.parse(process.env.A).product_name || ''" --eval "" 2>/dev/null)" || true
          export A="$answers"
          PRODUCT_NAME="$(node -p "JSON.parse(process.env.A).product_name")"
          OFFER_TYPE="$(node -p "JSON.parse(process.env.A).offer_type")"
          DELIVERY_METHOD="$(node -p "JSON.parse(process.env.A).delivery_method")"
          PLATFORMS="$(node -p "JSON.parse(process.env.A).platforms")"
          PRICING_MODEL="$(node -p "JSON.parse(process.env.A).pricing_model")"
          PRIMARY_CTA="$(node -p "JSON.parse(process.env.A).primary_cta")"

          # log variables before rendering
          echo "PRODUCT_NAME=$PRODUCT_NAME"
          echo "OFFER_TYPE=$OFFER_TYPE"
          echo "DELIVERY_METHOD=$DELIVERY_METHOD"
          echo "PLATFORMS=$PLATFORMS"
          echo "PRICING_MODEL=$PRICING_MODEL"
          echo "PRIMARY_CTA=$PRIMARY_CTA"

          export PRODUCT_NAME OFFER_TYPE DELIVERY_METHOD PLATFORMS PRICING_MODEL PRIMARY_CTA

          mkdir -p coming-soon/src/components

          # Render Vue templates
          envsubst < .github/templates/autoui/Landing.vue.template > coming-soon/src/Landing.vue
          envsubst < .github/templates/autoui/StatsChart.vue.template > coming-soon/src/components/StatsChart.vue

          # Ensure App.vue uses Landing
          cp coming-soon/src/App.vue coming-soon/src/App.vue.bak || true
          cat > coming-soon/src/App.vue <<'EOF'
          import Landing from "./Landing.vue";
          export default Landing;
          EOF

          # Add AntV dependency if missing
          cd coming-soon
          if ! cat package.json | grep -q '"@antv/g2"'; then
            npm install @antv/g2
          fi

          cd ..
          git status --porcelain

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add coming-soon/src/Landing.vue coming-soon/src/components/StatsChart.vue coming-soon/src/App.vue coming-soon/package.json coming-soon/package-lock.json
          git commit -m "AutoUI: generate Vue landing + AntV chart" || true
          git push

      - name: Comment completion
        if: ${{ steps.decide.outputs.complete == 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const discussionId = context.payload.discussion.node_id;
            const body =
             `AutoUI complete ✅
             I generated:
             - \`coming-soon/src/Landing.vue\`
             - \`coming-soon/src/components/StatsChart.vue\` (AntV G2)
             - updated \`coming-soon/src/App.vue\`
             Your Pages deploy workflow should publish it on the next run.`;
            await github.graphql(
              `mutation($discussionId: ID!, $body: String!) {
                addDiscussionComment(input: { discussionId: $discussionId, body: $body }) {
                  comment { id }
                }
              }`,
              { discussionId, body }
            );
